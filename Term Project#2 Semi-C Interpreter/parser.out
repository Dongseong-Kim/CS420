Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> source
Rule 1     source -> declarefunc
Rule 2     declarefunc -> func declarefunc
Rule 3     declarefunc -> func
Rule 4     func -> INT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE
Rule 5     func -> FLOAT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE
Rule 6     func -> INT ID LPAREN RPAREN LBRACE stmtlist RBRACE
Rule 7     func -> FLOAT ID LPAREN RPAREN LBRACE stmtlist RBRACE
Rule 8     paramlist -> param COMMA paramlist
Rule 9     paramlist -> param
Rule 10    param -> VOID
Rule 11    param -> INT ID
Rule 12    param -> FLOAT ID
Rule 13    param -> INT STAR ID
Rule 14    param -> FLOAT STAR ID
Rule 15    stmtlist -> stmt stmtlist
Rule 16    stmtlist -> stmt
Rule 17    stmt -> return SEMICOLON
Rule 18    stmt -> declarevar SEMICOLON
Rule 19    stmt -> assignvar SEMICOLON
Rule 20    stmt -> forloop
Rule 21    stmt -> incre
Rule 22    stmt -> if
Rule 23    stmt -> funccall SEMICOLON
Rule 24    return -> RETURN
Rule 25    return -> RETURN arithexp
Rule 26    forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE
Rule 27    if -> IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE
Rule 28    funccall -> ID LPAREN arglist RPAREN
Rule 29    funccall -> ID LPAREN RPAREN
Rule 30    arglist -> arg COMMA arglist
Rule 31    arglist -> arg
Rule 32    arg -> arithexp
Rule 33    arg -> string
Rule 34    declarevar -> INT varlist
Rule 35    declarevar -> FLOAT varlist
Rule 36    declarevar -> INT STAR varlist
Rule 37    declarevar -> FLOAT STAR varlist
Rule 38    varlist -> id COMMA varlist
Rule 39    varlist -> id
Rule 40    assignvar -> id ASSIGN arithexp
Rule 41    arithexp -> LPAREN arithexp RPAREN
Rule 42    arithexp -> term arithexptail
Rule 43    arithexp -> term
Rule 44    arithexptail -> PLUS term arithexptail
Rule 45    arithexptail -> PLUS term
Rule 46    arithexptail -> MINUS term arithexptail
Rule 47    arithexptail -> MINUS term
Rule 48    term -> factor termtail
Rule 49    term -> factor
Rule 50    termtail -> STAR factor termtail
Rule 51    termtail -> STAR factor
Rule 52    termtail -> DIVIDE factor termtail
Rule 53    termtail -> DIVIDE factor
Rule 54    factor -> NUMBER
Rule 55    factor -> PLUS NUMBER
Rule 56    factor -> MINUS NUMBER
Rule 57    factor -> incre
Rule 58    incre -> INCREMENT id
Rule 59    incre -> id INCREMENT
Rule 60    factor -> id
Rule 61    factor -> funccall
Rule 62    id -> ID
Rule 63    id -> ID LBRACKET arithexp RBRACKET
Rule 64    cmp -> LGREATER
Rule 65    cmp -> RGREATER
Rule 66    cmp -> EQUAL
Rule 67    cmp -> NOTEQUAL
Rule 68    cmp -> RGREQUAL
Rule 69    cmp -> LGREQUAL
Rule 70    string -> STRING

Terminals, with rules where they appear

ASSIGN               : 26 40
COMMA                : 8 30 38
DIVIDE               : 52 53
EQUAL                : 66
FLOAT                : 5 7 12 14 35 37
FOR                  : 26
ID                   : 4 5 6 7 11 12 13 14 28 29 62 63
IF                   : 27
INCREMENT            : 58 59
INT                  : 4 6 11 13 34 36
LBRACE               : 4 5 6 7 26 27
LBRACKET             : 63
LGREATER             : 64
LGREQUAL             : 69
LPAREN               : 4 5 6 7 26 27 28 29 41
MINUS                : 46 47 56
NOTEQUAL             : 67
NUMBER               : 54 55 56
PLUS                 : 44 45 55
RBRACE               : 4 5 6 7 26 27
RBRACKET             : 63
RETURN               : 24 25
RGREATER             : 65
RGREQUAL             : 68
RPAREN               : 4 5 6 7 26 27 28 29 41
SEMICOLON            : 17 18 19 23 26 26
STAR                 : 13 14 36 37 50 51
STRING               : 70
VOID                 : 10
error                : 

Nonterminals, with rules where they appear

arg                  : 30 31
arglist              : 28 30
arithexp             : 25 26 26 27 27 32 40 41 63
arithexptail         : 42 44 46
assignvar            : 19
cmp                  : 26 27
declarefunc          : 1 2
declarevar           : 18
factor               : 48 49 50 51 52 53
forloop              : 20
func                 : 2 3
funccall             : 23 61
id                   : 26 26 38 39 40 58 59 60
if                   : 22
incre                : 21 26 57
param                : 8 9
paramlist            : 4 5 8
return               : 17
source               : 0
stmt                 : 15 16
stmtlist             : 4 5 6 7 15 26 27
string               : 33
term                 : 42 43 44 45 46 47
termtail             : 48 50 52
varlist              : 34 35 36 37 38

Parsing method: LALR

state 0

    (0) S' -> . source
    (1) source -> . declarefunc
    (2) declarefunc -> . func declarefunc
    (3) declarefunc -> . func
    (4) func -> . INT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE
    (5) func -> . FLOAT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE
    (6) func -> . INT ID LPAREN RPAREN LBRACE stmtlist RBRACE
    (7) func -> . FLOAT ID LPAREN RPAREN LBRACE stmtlist RBRACE

    INT             shift and go to state 4
    FLOAT           shift and go to state 5

    source                         shift and go to state 1
    declarefunc                    shift and go to state 2
    func                           shift and go to state 3

state 1

    (0) S' -> source .



state 2

    (1) source -> declarefunc .

    $end            reduce using rule 1 (source -> declarefunc .)


state 3

    (2) declarefunc -> func . declarefunc
    (3) declarefunc -> func .
    (2) declarefunc -> . func declarefunc
    (3) declarefunc -> . func
    (4) func -> . INT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE
    (5) func -> . FLOAT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE
    (6) func -> . INT ID LPAREN RPAREN LBRACE stmtlist RBRACE
    (7) func -> . FLOAT ID LPAREN RPAREN LBRACE stmtlist RBRACE

    $end            reduce using rule 3 (declarefunc -> func .)
    INT             shift and go to state 4
    FLOAT           shift and go to state 5

    func                           shift and go to state 3
    declarefunc                    shift and go to state 6

state 4

    (4) func -> INT . ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE
    (6) func -> INT . ID LPAREN RPAREN LBRACE stmtlist RBRACE

    ID              shift and go to state 7


state 5

    (5) func -> FLOAT . ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE
    (7) func -> FLOAT . ID LPAREN RPAREN LBRACE stmtlist RBRACE

    ID              shift and go to state 8


state 6

    (2) declarefunc -> func declarefunc .

    $end            reduce using rule 2 (declarefunc -> func declarefunc .)


state 7

    (4) func -> INT ID . LPAREN paramlist RPAREN LBRACE stmtlist RBRACE
    (6) func -> INT ID . LPAREN RPAREN LBRACE stmtlist RBRACE

    LPAREN          shift and go to state 9


state 8

    (5) func -> FLOAT ID . LPAREN paramlist RPAREN LBRACE stmtlist RBRACE
    (7) func -> FLOAT ID . LPAREN RPAREN LBRACE stmtlist RBRACE

    LPAREN          shift and go to state 10


state 9

    (4) func -> INT ID LPAREN . paramlist RPAREN LBRACE stmtlist RBRACE
    (6) func -> INT ID LPAREN . RPAREN LBRACE stmtlist RBRACE
    (8) paramlist -> . param COMMA paramlist
    (9) paramlist -> . param
    (10) param -> . VOID
    (11) param -> . INT ID
    (12) param -> . FLOAT ID
    (13) param -> . INT STAR ID
    (14) param -> . FLOAT STAR ID

    RPAREN          shift and go to state 13
    VOID            shift and go to state 15
    INT             shift and go to state 11
    FLOAT           shift and go to state 16

    paramlist                      shift and go to state 12
    param                          shift and go to state 14

state 10

    (5) func -> FLOAT ID LPAREN . paramlist RPAREN LBRACE stmtlist RBRACE
    (7) func -> FLOAT ID LPAREN . RPAREN LBRACE stmtlist RBRACE
    (8) paramlist -> . param COMMA paramlist
    (9) paramlist -> . param
    (10) param -> . VOID
    (11) param -> . INT ID
    (12) param -> . FLOAT ID
    (13) param -> . INT STAR ID
    (14) param -> . FLOAT STAR ID

    RPAREN          shift and go to state 18
    VOID            shift and go to state 15
    INT             shift and go to state 11
    FLOAT           shift and go to state 16

    paramlist                      shift and go to state 17
    param                          shift and go to state 14

state 11

    (11) param -> INT . ID
    (13) param -> INT . STAR ID

    ID              shift and go to state 19
    STAR            shift and go to state 20


state 12

    (4) func -> INT ID LPAREN paramlist . RPAREN LBRACE stmtlist RBRACE

    RPAREN          shift and go to state 21


state 13

    (6) func -> INT ID LPAREN RPAREN . LBRACE stmtlist RBRACE

    LBRACE          shift and go to state 22


state 14

    (8) paramlist -> param . COMMA paramlist
    (9) paramlist -> param .

    COMMA           shift and go to state 23
    RPAREN          reduce using rule 9 (paramlist -> param .)


state 15

    (10) param -> VOID .

    COMMA           reduce using rule 10 (param -> VOID .)
    RPAREN          reduce using rule 10 (param -> VOID .)


state 16

    (12) param -> FLOAT . ID
    (14) param -> FLOAT . STAR ID

    ID              shift and go to state 24
    STAR            shift and go to state 25


state 17

    (5) func -> FLOAT ID LPAREN paramlist . RPAREN LBRACE stmtlist RBRACE

    RPAREN          shift and go to state 26


state 18

    (7) func -> FLOAT ID LPAREN RPAREN . LBRACE stmtlist RBRACE

    LBRACE          shift and go to state 27


state 19

    (11) param -> INT ID .

    COMMA           reduce using rule 11 (param -> INT ID .)
    RPAREN          reduce using rule 11 (param -> INT ID .)


state 20

    (13) param -> INT STAR . ID

    ID              shift and go to state 28


state 21

    (4) func -> INT ID LPAREN paramlist RPAREN . LBRACE stmtlist RBRACE

    LBRACE          shift and go to state 29


state 22

    (6) func -> INT ID LPAREN RPAREN LBRACE . stmtlist RBRACE
    (15) stmtlist -> . stmt stmtlist
    (16) stmtlist -> . stmt
    (17) stmt -> . return SEMICOLON
    (18) stmt -> . declarevar SEMICOLON
    (19) stmt -> . assignvar SEMICOLON
    (20) stmt -> . forloop
    (21) stmt -> . incre
    (22) stmt -> . if
    (23) stmt -> . funccall SEMICOLON
    (24) return -> . RETURN
    (25) return -> . RETURN arithexp
    (34) declarevar -> . INT varlist
    (35) declarevar -> . FLOAT varlist
    (36) declarevar -> . INT STAR varlist
    (37) declarevar -> . FLOAT STAR varlist
    (40) assignvar -> . id ASSIGN arithexp
    (26) forloop -> . FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (27) if -> . IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    RETURN          shift and go to state 41
    INT             shift and go to state 30
    FLOAT           shift and go to state 42
    FOR             shift and go to state 44
    INCREMENT       shift and go to state 45
    IF              shift and go to state 46
    ID              shift and go to state 31

    stmtlist                       shift and go to state 32
    stmt                           shift and go to state 33
    return                         shift and go to state 34
    declarevar                     shift and go to state 35
    assignvar                      shift and go to state 36
    forloop                        shift and go to state 37
    incre                          shift and go to state 38
    if                             shift and go to state 39
    funccall                       shift and go to state 40
    id                             shift and go to state 43

state 23

    (8) paramlist -> param COMMA . paramlist
    (8) paramlist -> . param COMMA paramlist
    (9) paramlist -> . param
    (10) param -> . VOID
    (11) param -> . INT ID
    (12) param -> . FLOAT ID
    (13) param -> . INT STAR ID
    (14) param -> . FLOAT STAR ID

    VOID            shift and go to state 15
    INT             shift and go to state 11
    FLOAT           shift and go to state 16

    param                          shift and go to state 14
    paramlist                      shift and go to state 47

state 24

    (12) param -> FLOAT ID .

    COMMA           reduce using rule 12 (param -> FLOAT ID .)
    RPAREN          reduce using rule 12 (param -> FLOAT ID .)


state 25

    (14) param -> FLOAT STAR . ID

    ID              shift and go to state 48


state 26

    (5) func -> FLOAT ID LPAREN paramlist RPAREN . LBRACE stmtlist RBRACE

    LBRACE          shift and go to state 49


state 27

    (7) func -> FLOAT ID LPAREN RPAREN LBRACE . stmtlist RBRACE
    (15) stmtlist -> . stmt stmtlist
    (16) stmtlist -> . stmt
    (17) stmt -> . return SEMICOLON
    (18) stmt -> . declarevar SEMICOLON
    (19) stmt -> . assignvar SEMICOLON
    (20) stmt -> . forloop
    (21) stmt -> . incre
    (22) stmt -> . if
    (23) stmt -> . funccall SEMICOLON
    (24) return -> . RETURN
    (25) return -> . RETURN arithexp
    (34) declarevar -> . INT varlist
    (35) declarevar -> . FLOAT varlist
    (36) declarevar -> . INT STAR varlist
    (37) declarevar -> . FLOAT STAR varlist
    (40) assignvar -> . id ASSIGN arithexp
    (26) forloop -> . FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (27) if -> . IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    RETURN          shift and go to state 41
    INT             shift and go to state 30
    FLOAT           shift and go to state 42
    FOR             shift and go to state 44
    INCREMENT       shift and go to state 45
    IF              shift and go to state 46
    ID              shift and go to state 31

    stmtlist                       shift and go to state 50
    stmt                           shift and go to state 33
    return                         shift and go to state 34
    declarevar                     shift and go to state 35
    assignvar                      shift and go to state 36
    forloop                        shift and go to state 37
    incre                          shift and go to state 38
    if                             shift and go to state 39
    funccall                       shift and go to state 40
    id                             shift and go to state 43

state 28

    (13) param -> INT STAR ID .

    COMMA           reduce using rule 13 (param -> INT STAR ID .)
    RPAREN          reduce using rule 13 (param -> INT STAR ID .)


state 29

    (4) func -> INT ID LPAREN paramlist RPAREN LBRACE . stmtlist RBRACE
    (15) stmtlist -> . stmt stmtlist
    (16) stmtlist -> . stmt
    (17) stmt -> . return SEMICOLON
    (18) stmt -> . declarevar SEMICOLON
    (19) stmt -> . assignvar SEMICOLON
    (20) stmt -> . forloop
    (21) stmt -> . incre
    (22) stmt -> . if
    (23) stmt -> . funccall SEMICOLON
    (24) return -> . RETURN
    (25) return -> . RETURN arithexp
    (34) declarevar -> . INT varlist
    (35) declarevar -> . FLOAT varlist
    (36) declarevar -> . INT STAR varlist
    (37) declarevar -> . FLOAT STAR varlist
    (40) assignvar -> . id ASSIGN arithexp
    (26) forloop -> . FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (27) if -> . IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    RETURN          shift and go to state 41
    INT             shift and go to state 30
    FLOAT           shift and go to state 42
    FOR             shift and go to state 44
    INCREMENT       shift and go to state 45
    IF              shift and go to state 46
    ID              shift and go to state 31

    stmtlist                       shift and go to state 51
    stmt                           shift and go to state 33
    return                         shift and go to state 34
    declarevar                     shift and go to state 35
    assignvar                      shift and go to state 36
    forloop                        shift and go to state 37
    incre                          shift and go to state 38
    if                             shift and go to state 39
    funccall                       shift and go to state 40
    id                             shift and go to state 43

state 30

    (34) declarevar -> INT . varlist
    (36) declarevar -> INT . STAR varlist
    (38) varlist -> . id COMMA varlist
    (39) varlist -> . id
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    STAR            shift and go to state 53
    ID              shift and go to state 55

    varlist                        shift and go to state 52
    id                             shift and go to state 54

state 31

    (28) funccall -> ID . LPAREN arglist RPAREN
    (29) funccall -> ID . LPAREN RPAREN
    (62) id -> ID .
    (63) id -> ID . LBRACKET arithexp RBRACKET

    LPAREN          shift and go to state 56
    ASSIGN          reduce using rule 62 (id -> ID .)
    INCREMENT       reduce using rule 62 (id -> ID .)
    LBRACKET        shift and go to state 57


state 32

    (6) func -> INT ID LPAREN RPAREN LBRACE stmtlist . RBRACE

    RBRACE          shift and go to state 58


state 33

    (15) stmtlist -> stmt . stmtlist
    (16) stmtlist -> stmt .
    (15) stmtlist -> . stmt stmtlist
    (16) stmtlist -> . stmt
    (17) stmt -> . return SEMICOLON
    (18) stmt -> . declarevar SEMICOLON
    (19) stmt -> . assignvar SEMICOLON
    (20) stmt -> . forloop
    (21) stmt -> . incre
    (22) stmt -> . if
    (23) stmt -> . funccall SEMICOLON
    (24) return -> . RETURN
    (25) return -> . RETURN arithexp
    (34) declarevar -> . INT varlist
    (35) declarevar -> . FLOAT varlist
    (36) declarevar -> . INT STAR varlist
    (37) declarevar -> . FLOAT STAR varlist
    (40) assignvar -> . id ASSIGN arithexp
    (26) forloop -> . FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (27) if -> . IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    RBRACE          reduce using rule 16 (stmtlist -> stmt .)
    RETURN          shift and go to state 41
    INT             shift and go to state 30
    FLOAT           shift and go to state 42
    FOR             shift and go to state 44
    INCREMENT       shift and go to state 45
    IF              shift and go to state 46
    ID              shift and go to state 31

    stmt                           shift and go to state 33
    stmtlist                       shift and go to state 59
    return                         shift and go to state 34
    declarevar                     shift and go to state 35
    assignvar                      shift and go to state 36
    forloop                        shift and go to state 37
    incre                          shift and go to state 38
    if                             shift and go to state 39
    funccall                       shift and go to state 40
    id                             shift and go to state 43

state 34

    (17) stmt -> return . SEMICOLON

    SEMICOLON       shift and go to state 60


state 35

    (18) stmt -> declarevar . SEMICOLON

    SEMICOLON       shift and go to state 61


state 36

    (19) stmt -> assignvar . SEMICOLON

    SEMICOLON       shift and go to state 62


state 37

    (20) stmt -> forloop .

    RETURN          reduce using rule 20 (stmt -> forloop .)
    INT             reduce using rule 20 (stmt -> forloop .)
    FLOAT           reduce using rule 20 (stmt -> forloop .)
    FOR             reduce using rule 20 (stmt -> forloop .)
    INCREMENT       reduce using rule 20 (stmt -> forloop .)
    IF              reduce using rule 20 (stmt -> forloop .)
    ID              reduce using rule 20 (stmt -> forloop .)
    RBRACE          reduce using rule 20 (stmt -> forloop .)


state 38

    (21) stmt -> incre .

    RETURN          reduce using rule 21 (stmt -> incre .)
    INT             reduce using rule 21 (stmt -> incre .)
    FLOAT           reduce using rule 21 (stmt -> incre .)
    FOR             reduce using rule 21 (stmt -> incre .)
    INCREMENT       reduce using rule 21 (stmt -> incre .)
    IF              reduce using rule 21 (stmt -> incre .)
    ID              reduce using rule 21 (stmt -> incre .)
    RBRACE          reduce using rule 21 (stmt -> incre .)


state 39

    (22) stmt -> if .

    RETURN          reduce using rule 22 (stmt -> if .)
    INT             reduce using rule 22 (stmt -> if .)
    FLOAT           reduce using rule 22 (stmt -> if .)
    FOR             reduce using rule 22 (stmt -> if .)
    INCREMENT       reduce using rule 22 (stmt -> if .)
    IF              reduce using rule 22 (stmt -> if .)
    ID              reduce using rule 22 (stmt -> if .)
    RBRACE          reduce using rule 22 (stmt -> if .)


state 40

    (23) stmt -> funccall . SEMICOLON

    SEMICOLON       shift and go to state 63


state 41

    (24) return -> RETURN .
    (25) return -> RETURN . arithexp
    (41) arithexp -> . LPAREN arithexp RPAREN
    (42) arithexp -> . term arithexptail
    (43) arithexp -> . term
    (48) term -> . factor termtail
    (49) term -> . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    SEMICOLON       reduce using rule 24 (return -> RETURN .)
    LPAREN          shift and go to state 65
    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    arithexp                       shift and go to state 64
    term                           shift and go to state 66
    factor                         shift and go to state 67
    incre                          shift and go to state 71
    id                             shift and go to state 72
    funccall                       shift and go to state 73

state 42

    (35) declarevar -> FLOAT . varlist
    (37) declarevar -> FLOAT . STAR varlist
    (38) varlist -> . id COMMA varlist
    (39) varlist -> . id
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    STAR            shift and go to state 76
    ID              shift and go to state 55

    varlist                        shift and go to state 75
    id                             shift and go to state 54

state 43

    (40) assignvar -> id . ASSIGN arithexp
    (59) incre -> id . INCREMENT

    ASSIGN          shift and go to state 77
    INCREMENT       shift and go to state 78


state 44

    (26) forloop -> FOR . LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE

    LPAREN          shift and go to state 79


state 45

    (58) incre -> INCREMENT . id
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    ID              shift and go to state 55

    id                             shift and go to state 80

state 46

    (27) if -> IF . LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE

    LPAREN          shift and go to state 81


state 47

    (8) paramlist -> param COMMA paramlist .

    RPAREN          reduce using rule 8 (paramlist -> param COMMA paramlist .)


state 48

    (14) param -> FLOAT STAR ID .

    COMMA           reduce using rule 14 (param -> FLOAT STAR ID .)
    RPAREN          reduce using rule 14 (param -> FLOAT STAR ID .)


state 49

    (5) func -> FLOAT ID LPAREN paramlist RPAREN LBRACE . stmtlist RBRACE
    (15) stmtlist -> . stmt stmtlist
    (16) stmtlist -> . stmt
    (17) stmt -> . return SEMICOLON
    (18) stmt -> . declarevar SEMICOLON
    (19) stmt -> . assignvar SEMICOLON
    (20) stmt -> . forloop
    (21) stmt -> . incre
    (22) stmt -> . if
    (23) stmt -> . funccall SEMICOLON
    (24) return -> . RETURN
    (25) return -> . RETURN arithexp
    (34) declarevar -> . INT varlist
    (35) declarevar -> . FLOAT varlist
    (36) declarevar -> . INT STAR varlist
    (37) declarevar -> . FLOAT STAR varlist
    (40) assignvar -> . id ASSIGN arithexp
    (26) forloop -> . FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (27) if -> . IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    RETURN          shift and go to state 41
    INT             shift and go to state 30
    FLOAT           shift and go to state 42
    FOR             shift and go to state 44
    INCREMENT       shift and go to state 45
    IF              shift and go to state 46
    ID              shift and go to state 31

    stmtlist                       shift and go to state 82
    stmt                           shift and go to state 33
    return                         shift and go to state 34
    declarevar                     shift and go to state 35
    assignvar                      shift and go to state 36
    forloop                        shift and go to state 37
    incre                          shift and go to state 38
    if                             shift and go to state 39
    funccall                       shift and go to state 40
    id                             shift and go to state 43

state 50

    (7) func -> FLOAT ID LPAREN RPAREN LBRACE stmtlist . RBRACE

    RBRACE          shift and go to state 83


state 51

    (4) func -> INT ID LPAREN paramlist RPAREN LBRACE stmtlist . RBRACE

    RBRACE          shift and go to state 84


state 52

    (34) declarevar -> INT varlist .

    SEMICOLON       reduce using rule 34 (declarevar -> INT varlist .)


state 53

    (36) declarevar -> INT STAR . varlist
    (38) varlist -> . id COMMA varlist
    (39) varlist -> . id
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    ID              shift and go to state 55

    varlist                        shift and go to state 85
    id                             shift and go to state 54

state 54

    (38) varlist -> id . COMMA varlist
    (39) varlist -> id .

    COMMA           shift and go to state 86
    SEMICOLON       reduce using rule 39 (varlist -> id .)


state 55

    (62) id -> ID .
    (63) id -> ID . LBRACKET arithexp RBRACKET

    COMMA           reduce using rule 62 (id -> ID .)
    SEMICOLON       reduce using rule 62 (id -> ID .)
    RETURN          reduce using rule 62 (id -> ID .)
    INT             reduce using rule 62 (id -> ID .)
    FLOAT           reduce using rule 62 (id -> ID .)
    FOR             reduce using rule 62 (id -> ID .)
    INCREMENT       reduce using rule 62 (id -> ID .)
    IF              reduce using rule 62 (id -> ID .)
    ID              reduce using rule 62 (id -> ID .)
    RBRACE          reduce using rule 62 (id -> ID .)
    STAR            reduce using rule 62 (id -> ID .)
    DIVIDE          reduce using rule 62 (id -> ID .)
    PLUS            reduce using rule 62 (id -> ID .)
    MINUS           reduce using rule 62 (id -> ID .)
    RPAREN          reduce using rule 62 (id -> ID .)
    RBRACKET        reduce using rule 62 (id -> ID .)
    LGREATER        reduce using rule 62 (id -> ID .)
    RGREATER        reduce using rule 62 (id -> ID .)
    EQUAL           reduce using rule 62 (id -> ID .)
    NOTEQUAL        reduce using rule 62 (id -> ID .)
    RGREQUAL        reduce using rule 62 (id -> ID .)
    LGREQUAL        reduce using rule 62 (id -> ID .)
    ASSIGN          reduce using rule 62 (id -> ID .)
    LBRACKET        shift and go to state 57


state 56

    (28) funccall -> ID LPAREN . arglist RPAREN
    (29) funccall -> ID LPAREN . RPAREN
    (30) arglist -> . arg COMMA arglist
    (31) arglist -> . arg
    (32) arg -> . arithexp
    (33) arg -> . string
    (41) arithexp -> . LPAREN arithexp RPAREN
    (42) arithexp -> . term arithexptail
    (43) arithexp -> . term
    (70) string -> . STRING
    (48) term -> . factor termtail
    (49) term -> . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    RPAREN          shift and go to state 88
    LPAREN          shift and go to state 65
    STRING          shift and go to state 92
    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    arglist                        shift and go to state 87
    arg                            shift and go to state 89
    arithexp                       shift and go to state 90
    string                         shift and go to state 91
    term                           shift and go to state 66
    factor                         shift and go to state 67
    incre                          shift and go to state 71
    id                             shift and go to state 72
    funccall                       shift and go to state 73

state 57

    (63) id -> ID LBRACKET . arithexp RBRACKET
    (41) arithexp -> . LPAREN arithexp RPAREN
    (42) arithexp -> . term arithexptail
    (43) arithexp -> . term
    (48) term -> . factor termtail
    (49) term -> . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 65
    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    arithexp                       shift and go to state 93
    term                           shift and go to state 66
    factor                         shift and go to state 67
    incre                          shift and go to state 71
    id                             shift and go to state 72
    funccall                       shift and go to state 73

state 58

    (6) func -> INT ID LPAREN RPAREN LBRACE stmtlist RBRACE .

    INT             reduce using rule 6 (func -> INT ID LPAREN RPAREN LBRACE stmtlist RBRACE .)
    FLOAT           reduce using rule 6 (func -> INT ID LPAREN RPAREN LBRACE stmtlist RBRACE .)
    $end            reduce using rule 6 (func -> INT ID LPAREN RPAREN LBRACE stmtlist RBRACE .)


state 59

    (15) stmtlist -> stmt stmtlist .

    RBRACE          reduce using rule 15 (stmtlist -> stmt stmtlist .)


state 60

    (17) stmt -> return SEMICOLON .

    RETURN          reduce using rule 17 (stmt -> return SEMICOLON .)
    INT             reduce using rule 17 (stmt -> return SEMICOLON .)
    FLOAT           reduce using rule 17 (stmt -> return SEMICOLON .)
    FOR             reduce using rule 17 (stmt -> return SEMICOLON .)
    INCREMENT       reduce using rule 17 (stmt -> return SEMICOLON .)
    IF              reduce using rule 17 (stmt -> return SEMICOLON .)
    ID              reduce using rule 17 (stmt -> return SEMICOLON .)
    RBRACE          reduce using rule 17 (stmt -> return SEMICOLON .)


state 61

    (18) stmt -> declarevar SEMICOLON .

    RETURN          reduce using rule 18 (stmt -> declarevar SEMICOLON .)
    INT             reduce using rule 18 (stmt -> declarevar SEMICOLON .)
    FLOAT           reduce using rule 18 (stmt -> declarevar SEMICOLON .)
    FOR             reduce using rule 18 (stmt -> declarevar SEMICOLON .)
    INCREMENT       reduce using rule 18 (stmt -> declarevar SEMICOLON .)
    IF              reduce using rule 18 (stmt -> declarevar SEMICOLON .)
    ID              reduce using rule 18 (stmt -> declarevar SEMICOLON .)
    RBRACE          reduce using rule 18 (stmt -> declarevar SEMICOLON .)


state 62

    (19) stmt -> assignvar SEMICOLON .

    RETURN          reduce using rule 19 (stmt -> assignvar SEMICOLON .)
    INT             reduce using rule 19 (stmt -> assignvar SEMICOLON .)
    FLOAT           reduce using rule 19 (stmt -> assignvar SEMICOLON .)
    FOR             reduce using rule 19 (stmt -> assignvar SEMICOLON .)
    INCREMENT       reduce using rule 19 (stmt -> assignvar SEMICOLON .)
    IF              reduce using rule 19 (stmt -> assignvar SEMICOLON .)
    ID              reduce using rule 19 (stmt -> assignvar SEMICOLON .)
    RBRACE          reduce using rule 19 (stmt -> assignvar SEMICOLON .)


state 63

    (23) stmt -> funccall SEMICOLON .

    RETURN          reduce using rule 23 (stmt -> funccall SEMICOLON .)
    INT             reduce using rule 23 (stmt -> funccall SEMICOLON .)
    FLOAT           reduce using rule 23 (stmt -> funccall SEMICOLON .)
    FOR             reduce using rule 23 (stmt -> funccall SEMICOLON .)
    INCREMENT       reduce using rule 23 (stmt -> funccall SEMICOLON .)
    IF              reduce using rule 23 (stmt -> funccall SEMICOLON .)
    ID              reduce using rule 23 (stmt -> funccall SEMICOLON .)
    RBRACE          reduce using rule 23 (stmt -> funccall SEMICOLON .)


state 64

    (25) return -> RETURN arithexp .

    SEMICOLON       reduce using rule 25 (return -> RETURN arithexp .)


state 65

    (41) arithexp -> LPAREN . arithexp RPAREN
    (41) arithexp -> . LPAREN arithexp RPAREN
    (42) arithexp -> . term arithexptail
    (43) arithexp -> . term
    (48) term -> . factor termtail
    (49) term -> . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 65
    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    arithexp                       shift and go to state 94
    term                           shift and go to state 66
    factor                         shift and go to state 67
    incre                          shift and go to state 71
    id                             shift and go to state 72
    funccall                       shift and go to state 73

state 66

    (42) arithexp -> term . arithexptail
    (43) arithexp -> term .
    (44) arithexptail -> . PLUS term arithexptail
    (45) arithexptail -> . PLUS term
    (46) arithexptail -> . MINUS term arithexptail
    (47) arithexptail -> . MINUS term

    SEMICOLON       reduce using rule 43 (arithexp -> term .)
    COMMA           reduce using rule 43 (arithexp -> term .)
    RPAREN          reduce using rule 43 (arithexp -> term .)
    RBRACKET        reduce using rule 43 (arithexp -> term .)
    LGREATER        reduce using rule 43 (arithexp -> term .)
    RGREATER        reduce using rule 43 (arithexp -> term .)
    EQUAL           reduce using rule 43 (arithexp -> term .)
    NOTEQUAL        reduce using rule 43 (arithexp -> term .)
    RGREQUAL        reduce using rule 43 (arithexp -> term .)
    LGREQUAL        reduce using rule 43 (arithexp -> term .)
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97

    arithexptail                   shift and go to state 95

state 67

    (48) term -> factor . termtail
    (49) term -> factor .
    (50) termtail -> . STAR factor termtail
    (51) termtail -> . STAR factor
    (52) termtail -> . DIVIDE factor termtail
    (53) termtail -> . DIVIDE factor

    PLUS            reduce using rule 49 (term -> factor .)
    MINUS           reduce using rule 49 (term -> factor .)
    SEMICOLON       reduce using rule 49 (term -> factor .)
    COMMA           reduce using rule 49 (term -> factor .)
    RPAREN          reduce using rule 49 (term -> factor .)
    RBRACKET        reduce using rule 49 (term -> factor .)
    LGREATER        reduce using rule 49 (term -> factor .)
    RGREATER        reduce using rule 49 (term -> factor .)
    EQUAL           reduce using rule 49 (term -> factor .)
    NOTEQUAL        reduce using rule 49 (term -> factor .)
    RGREQUAL        reduce using rule 49 (term -> factor .)
    LGREQUAL        reduce using rule 49 (term -> factor .)
    STAR            shift and go to state 99
    DIVIDE          shift and go to state 100

    termtail                       shift and go to state 98

state 68

    (54) factor -> NUMBER .

    STAR            reduce using rule 54 (factor -> NUMBER .)
    DIVIDE          reduce using rule 54 (factor -> NUMBER .)
    PLUS            reduce using rule 54 (factor -> NUMBER .)
    MINUS           reduce using rule 54 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 54 (factor -> NUMBER .)
    COMMA           reduce using rule 54 (factor -> NUMBER .)
    RPAREN          reduce using rule 54 (factor -> NUMBER .)
    RBRACKET        reduce using rule 54 (factor -> NUMBER .)
    LGREATER        reduce using rule 54 (factor -> NUMBER .)
    RGREATER        reduce using rule 54 (factor -> NUMBER .)
    EQUAL           reduce using rule 54 (factor -> NUMBER .)
    NOTEQUAL        reduce using rule 54 (factor -> NUMBER .)
    RGREQUAL        reduce using rule 54 (factor -> NUMBER .)
    LGREQUAL        reduce using rule 54 (factor -> NUMBER .)


state 69

    (55) factor -> PLUS . NUMBER

    NUMBER          shift and go to state 101


state 70

    (56) factor -> MINUS . NUMBER

    NUMBER          shift and go to state 102


state 71

    (57) factor -> incre .

    STAR            reduce using rule 57 (factor -> incre .)
    DIVIDE          reduce using rule 57 (factor -> incre .)
    PLUS            reduce using rule 57 (factor -> incre .)
    MINUS           reduce using rule 57 (factor -> incre .)
    SEMICOLON       reduce using rule 57 (factor -> incre .)
    COMMA           reduce using rule 57 (factor -> incre .)
    RPAREN          reduce using rule 57 (factor -> incre .)
    RBRACKET        reduce using rule 57 (factor -> incre .)
    LGREATER        reduce using rule 57 (factor -> incre .)
    RGREATER        reduce using rule 57 (factor -> incre .)
    EQUAL           reduce using rule 57 (factor -> incre .)
    NOTEQUAL        reduce using rule 57 (factor -> incre .)
    RGREQUAL        reduce using rule 57 (factor -> incre .)
    LGREQUAL        reduce using rule 57 (factor -> incre .)


state 72

    (60) factor -> id .
    (59) incre -> id . INCREMENT

    STAR            reduce using rule 60 (factor -> id .)
    DIVIDE          reduce using rule 60 (factor -> id .)
    PLUS            reduce using rule 60 (factor -> id .)
    MINUS           reduce using rule 60 (factor -> id .)
    SEMICOLON       reduce using rule 60 (factor -> id .)
    COMMA           reduce using rule 60 (factor -> id .)
    RPAREN          reduce using rule 60 (factor -> id .)
    RBRACKET        reduce using rule 60 (factor -> id .)
    LGREATER        reduce using rule 60 (factor -> id .)
    RGREATER        reduce using rule 60 (factor -> id .)
    EQUAL           reduce using rule 60 (factor -> id .)
    NOTEQUAL        reduce using rule 60 (factor -> id .)
    RGREQUAL        reduce using rule 60 (factor -> id .)
    LGREQUAL        reduce using rule 60 (factor -> id .)
    INCREMENT       shift and go to state 78


state 73

    (61) factor -> funccall .

    STAR            reduce using rule 61 (factor -> funccall .)
    DIVIDE          reduce using rule 61 (factor -> funccall .)
    PLUS            reduce using rule 61 (factor -> funccall .)
    MINUS           reduce using rule 61 (factor -> funccall .)
    SEMICOLON       reduce using rule 61 (factor -> funccall .)
    COMMA           reduce using rule 61 (factor -> funccall .)
    RPAREN          reduce using rule 61 (factor -> funccall .)
    RBRACKET        reduce using rule 61 (factor -> funccall .)
    LGREATER        reduce using rule 61 (factor -> funccall .)
    RGREATER        reduce using rule 61 (factor -> funccall .)
    EQUAL           reduce using rule 61 (factor -> funccall .)
    NOTEQUAL        reduce using rule 61 (factor -> funccall .)
    RGREQUAL        reduce using rule 61 (factor -> funccall .)
    LGREQUAL        reduce using rule 61 (factor -> funccall .)


state 74

    (62) id -> ID .
    (63) id -> ID . LBRACKET arithexp RBRACKET
    (28) funccall -> ID . LPAREN arglist RPAREN
    (29) funccall -> ID . LPAREN RPAREN

    INCREMENT       reduce using rule 62 (id -> ID .)
    STAR            reduce using rule 62 (id -> ID .)
    DIVIDE          reduce using rule 62 (id -> ID .)
    PLUS            reduce using rule 62 (id -> ID .)
    MINUS           reduce using rule 62 (id -> ID .)
    SEMICOLON       reduce using rule 62 (id -> ID .)
    COMMA           reduce using rule 62 (id -> ID .)
    RPAREN          reduce using rule 62 (id -> ID .)
    RBRACKET        reduce using rule 62 (id -> ID .)
    LGREATER        reduce using rule 62 (id -> ID .)
    RGREATER        reduce using rule 62 (id -> ID .)
    EQUAL           reduce using rule 62 (id -> ID .)
    NOTEQUAL        reduce using rule 62 (id -> ID .)
    RGREQUAL        reduce using rule 62 (id -> ID .)
    LGREQUAL        reduce using rule 62 (id -> ID .)
    LBRACKET        shift and go to state 57
    LPAREN          shift and go to state 56


state 75

    (35) declarevar -> FLOAT varlist .

    SEMICOLON       reduce using rule 35 (declarevar -> FLOAT varlist .)


state 76

    (37) declarevar -> FLOAT STAR . varlist
    (38) varlist -> . id COMMA varlist
    (39) varlist -> . id
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    ID              shift and go to state 55

    varlist                        shift and go to state 103
    id                             shift and go to state 54

state 77

    (40) assignvar -> id ASSIGN . arithexp
    (41) arithexp -> . LPAREN arithexp RPAREN
    (42) arithexp -> . term arithexptail
    (43) arithexp -> . term
    (48) term -> . factor termtail
    (49) term -> . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 65
    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    id                             shift and go to state 72
    arithexp                       shift and go to state 104
    term                           shift and go to state 66
    factor                         shift and go to state 67
    incre                          shift and go to state 71
    funccall                       shift and go to state 73

state 78

    (59) incre -> id INCREMENT .

    RETURN          reduce using rule 59 (incre -> id INCREMENT .)
    INT             reduce using rule 59 (incre -> id INCREMENT .)
    FLOAT           reduce using rule 59 (incre -> id INCREMENT .)
    FOR             reduce using rule 59 (incre -> id INCREMENT .)
    INCREMENT       reduce using rule 59 (incre -> id INCREMENT .)
    IF              reduce using rule 59 (incre -> id INCREMENT .)
    ID              reduce using rule 59 (incre -> id INCREMENT .)
    RBRACE          reduce using rule 59 (incre -> id INCREMENT .)
    STAR            reduce using rule 59 (incre -> id INCREMENT .)
    DIVIDE          reduce using rule 59 (incre -> id INCREMENT .)
    PLUS            reduce using rule 59 (incre -> id INCREMENT .)
    MINUS           reduce using rule 59 (incre -> id INCREMENT .)
    SEMICOLON       reduce using rule 59 (incre -> id INCREMENT .)
    COMMA           reduce using rule 59 (incre -> id INCREMENT .)
    RPAREN          reduce using rule 59 (incre -> id INCREMENT .)
    RBRACKET        reduce using rule 59 (incre -> id INCREMENT .)
    LGREATER        reduce using rule 59 (incre -> id INCREMENT .)
    RGREATER        reduce using rule 59 (incre -> id INCREMENT .)
    EQUAL           reduce using rule 59 (incre -> id INCREMENT .)
    NOTEQUAL        reduce using rule 59 (incre -> id INCREMENT .)
    RGREQUAL        reduce using rule 59 (incre -> id INCREMENT .)
    LGREQUAL        reduce using rule 59 (incre -> id INCREMENT .)


state 79

    (26) forloop -> FOR LPAREN . id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    ID              shift and go to state 55

    id                             shift and go to state 105

state 80

    (58) incre -> INCREMENT id .

    RETURN          reduce using rule 58 (incre -> INCREMENT id .)
    INT             reduce using rule 58 (incre -> INCREMENT id .)
    FLOAT           reduce using rule 58 (incre -> INCREMENT id .)
    FOR             reduce using rule 58 (incre -> INCREMENT id .)
    INCREMENT       reduce using rule 58 (incre -> INCREMENT id .)
    IF              reduce using rule 58 (incre -> INCREMENT id .)
    ID              reduce using rule 58 (incre -> INCREMENT id .)
    RBRACE          reduce using rule 58 (incre -> INCREMENT id .)
    STAR            reduce using rule 58 (incre -> INCREMENT id .)
    DIVIDE          reduce using rule 58 (incre -> INCREMENT id .)
    PLUS            reduce using rule 58 (incre -> INCREMENT id .)
    MINUS           reduce using rule 58 (incre -> INCREMENT id .)
    SEMICOLON       reduce using rule 58 (incre -> INCREMENT id .)
    COMMA           reduce using rule 58 (incre -> INCREMENT id .)
    RPAREN          reduce using rule 58 (incre -> INCREMENT id .)
    RBRACKET        reduce using rule 58 (incre -> INCREMENT id .)
    LGREATER        reduce using rule 58 (incre -> INCREMENT id .)
    RGREATER        reduce using rule 58 (incre -> INCREMENT id .)
    EQUAL           reduce using rule 58 (incre -> INCREMENT id .)
    NOTEQUAL        reduce using rule 58 (incre -> INCREMENT id .)
    RGREQUAL        reduce using rule 58 (incre -> INCREMENT id .)
    LGREQUAL        reduce using rule 58 (incre -> INCREMENT id .)


state 81

    (27) if -> IF LPAREN . arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE
    (41) arithexp -> . LPAREN arithexp RPAREN
    (42) arithexp -> . term arithexptail
    (43) arithexp -> . term
    (48) term -> . factor termtail
    (49) term -> . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 65
    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    arithexp                       shift and go to state 106
    term                           shift and go to state 66
    factor                         shift and go to state 67
    incre                          shift and go to state 71
    id                             shift and go to state 72
    funccall                       shift and go to state 73

state 82

    (5) func -> FLOAT ID LPAREN paramlist RPAREN LBRACE stmtlist . RBRACE

    RBRACE          shift and go to state 107


state 83

    (7) func -> FLOAT ID LPAREN RPAREN LBRACE stmtlist RBRACE .

    INT             reduce using rule 7 (func -> FLOAT ID LPAREN RPAREN LBRACE stmtlist RBRACE .)
    FLOAT           reduce using rule 7 (func -> FLOAT ID LPAREN RPAREN LBRACE stmtlist RBRACE .)
    $end            reduce using rule 7 (func -> FLOAT ID LPAREN RPAREN LBRACE stmtlist RBRACE .)


state 84

    (4) func -> INT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE .

    INT             reduce using rule 4 (func -> INT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE .)
    FLOAT           reduce using rule 4 (func -> INT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE .)
    $end            reduce using rule 4 (func -> INT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE .)


state 85

    (36) declarevar -> INT STAR varlist .

    SEMICOLON       reduce using rule 36 (declarevar -> INT STAR varlist .)


state 86

    (38) varlist -> id COMMA . varlist
    (38) varlist -> . id COMMA varlist
    (39) varlist -> . id
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    ID              shift and go to state 55

    id                             shift and go to state 54
    varlist                        shift and go to state 108

state 87

    (28) funccall -> ID LPAREN arglist . RPAREN

    RPAREN          shift and go to state 109


state 88

    (29) funccall -> ID LPAREN RPAREN .

    SEMICOLON       reduce using rule 29 (funccall -> ID LPAREN RPAREN .)
    STAR            reduce using rule 29 (funccall -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 29 (funccall -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 29 (funccall -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 29 (funccall -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 29 (funccall -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 29 (funccall -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 29 (funccall -> ID LPAREN RPAREN .)
    LGREATER        reduce using rule 29 (funccall -> ID LPAREN RPAREN .)
    RGREATER        reduce using rule 29 (funccall -> ID LPAREN RPAREN .)
    EQUAL           reduce using rule 29 (funccall -> ID LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 29 (funccall -> ID LPAREN RPAREN .)
    RGREQUAL        reduce using rule 29 (funccall -> ID LPAREN RPAREN .)
    LGREQUAL        reduce using rule 29 (funccall -> ID LPAREN RPAREN .)


state 89

    (30) arglist -> arg . COMMA arglist
    (31) arglist -> arg .

    COMMA           shift and go to state 110
    RPAREN          reduce using rule 31 (arglist -> arg .)


state 90

    (32) arg -> arithexp .

    COMMA           reduce using rule 32 (arg -> arithexp .)
    RPAREN          reduce using rule 32 (arg -> arithexp .)


state 91

    (33) arg -> string .

    COMMA           reduce using rule 33 (arg -> string .)
    RPAREN          reduce using rule 33 (arg -> string .)


state 92

    (70) string -> STRING .

    COMMA           reduce using rule 70 (string -> STRING .)
    RPAREN          reduce using rule 70 (string -> STRING .)


state 93

    (63) id -> ID LBRACKET arithexp . RBRACKET

    RBRACKET        shift and go to state 111


state 94

    (41) arithexp -> LPAREN arithexp . RPAREN

    RPAREN          shift and go to state 112


state 95

    (42) arithexp -> term arithexptail .

    SEMICOLON       reduce using rule 42 (arithexp -> term arithexptail .)
    COMMA           reduce using rule 42 (arithexp -> term arithexptail .)
    RPAREN          reduce using rule 42 (arithexp -> term arithexptail .)
    RBRACKET        reduce using rule 42 (arithexp -> term arithexptail .)
    LGREATER        reduce using rule 42 (arithexp -> term arithexptail .)
    RGREATER        reduce using rule 42 (arithexp -> term arithexptail .)
    EQUAL           reduce using rule 42 (arithexp -> term arithexptail .)
    NOTEQUAL        reduce using rule 42 (arithexp -> term arithexptail .)
    RGREQUAL        reduce using rule 42 (arithexp -> term arithexptail .)
    LGREQUAL        reduce using rule 42 (arithexp -> term arithexptail .)


state 96

    (44) arithexptail -> PLUS . term arithexptail
    (45) arithexptail -> PLUS . term
    (48) term -> . factor termtail
    (49) term -> . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    term                           shift and go to state 113
    factor                         shift and go to state 67
    incre                          shift and go to state 71
    id                             shift and go to state 72
    funccall                       shift and go to state 73

state 97

    (46) arithexptail -> MINUS . term arithexptail
    (47) arithexptail -> MINUS . term
    (48) term -> . factor termtail
    (49) term -> . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    term                           shift and go to state 114
    factor                         shift and go to state 67
    incre                          shift and go to state 71
    id                             shift and go to state 72
    funccall                       shift and go to state 73

state 98

    (48) term -> factor termtail .

    PLUS            reduce using rule 48 (term -> factor termtail .)
    MINUS           reduce using rule 48 (term -> factor termtail .)
    SEMICOLON       reduce using rule 48 (term -> factor termtail .)
    COMMA           reduce using rule 48 (term -> factor termtail .)
    RPAREN          reduce using rule 48 (term -> factor termtail .)
    RBRACKET        reduce using rule 48 (term -> factor termtail .)
    LGREATER        reduce using rule 48 (term -> factor termtail .)
    RGREATER        reduce using rule 48 (term -> factor termtail .)
    EQUAL           reduce using rule 48 (term -> factor termtail .)
    NOTEQUAL        reduce using rule 48 (term -> factor termtail .)
    RGREQUAL        reduce using rule 48 (term -> factor termtail .)
    LGREQUAL        reduce using rule 48 (term -> factor termtail .)


state 99

    (50) termtail -> STAR . factor termtail
    (51) termtail -> STAR . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    factor                         shift and go to state 115
    incre                          shift and go to state 71
    id                             shift and go to state 72
    funccall                       shift and go to state 73

state 100

    (52) termtail -> DIVIDE . factor termtail
    (53) termtail -> DIVIDE . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    factor                         shift and go to state 116
    incre                          shift and go to state 71
    id                             shift and go to state 72
    funccall                       shift and go to state 73

state 101

    (55) factor -> PLUS NUMBER .

    STAR            reduce using rule 55 (factor -> PLUS NUMBER .)
    DIVIDE          reduce using rule 55 (factor -> PLUS NUMBER .)
    PLUS            reduce using rule 55 (factor -> PLUS NUMBER .)
    MINUS           reduce using rule 55 (factor -> PLUS NUMBER .)
    SEMICOLON       reduce using rule 55 (factor -> PLUS NUMBER .)
    COMMA           reduce using rule 55 (factor -> PLUS NUMBER .)
    RPAREN          reduce using rule 55 (factor -> PLUS NUMBER .)
    RBRACKET        reduce using rule 55 (factor -> PLUS NUMBER .)
    LGREATER        reduce using rule 55 (factor -> PLUS NUMBER .)
    RGREATER        reduce using rule 55 (factor -> PLUS NUMBER .)
    EQUAL           reduce using rule 55 (factor -> PLUS NUMBER .)
    NOTEQUAL        reduce using rule 55 (factor -> PLUS NUMBER .)
    RGREQUAL        reduce using rule 55 (factor -> PLUS NUMBER .)
    LGREQUAL        reduce using rule 55 (factor -> PLUS NUMBER .)


state 102

    (56) factor -> MINUS NUMBER .

    STAR            reduce using rule 56 (factor -> MINUS NUMBER .)
    DIVIDE          reduce using rule 56 (factor -> MINUS NUMBER .)
    PLUS            reduce using rule 56 (factor -> MINUS NUMBER .)
    MINUS           reduce using rule 56 (factor -> MINUS NUMBER .)
    SEMICOLON       reduce using rule 56 (factor -> MINUS NUMBER .)
    COMMA           reduce using rule 56 (factor -> MINUS NUMBER .)
    RPAREN          reduce using rule 56 (factor -> MINUS NUMBER .)
    RBRACKET        reduce using rule 56 (factor -> MINUS NUMBER .)
    LGREATER        reduce using rule 56 (factor -> MINUS NUMBER .)
    RGREATER        reduce using rule 56 (factor -> MINUS NUMBER .)
    EQUAL           reduce using rule 56 (factor -> MINUS NUMBER .)
    NOTEQUAL        reduce using rule 56 (factor -> MINUS NUMBER .)
    RGREQUAL        reduce using rule 56 (factor -> MINUS NUMBER .)
    LGREQUAL        reduce using rule 56 (factor -> MINUS NUMBER .)


state 103

    (37) declarevar -> FLOAT STAR varlist .

    SEMICOLON       reduce using rule 37 (declarevar -> FLOAT STAR varlist .)


state 104

    (40) assignvar -> id ASSIGN arithexp .

    SEMICOLON       reduce using rule 40 (assignvar -> id ASSIGN arithexp .)


state 105

    (26) forloop -> FOR LPAREN id . ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE

    ASSIGN          shift and go to state 117


state 106

    (27) if -> IF LPAREN arithexp . cmp arithexp RPAREN LBRACE stmtlist RBRACE
    (64) cmp -> . LGREATER
    (65) cmp -> . RGREATER
    (66) cmp -> . EQUAL
    (67) cmp -> . NOTEQUAL
    (68) cmp -> . RGREQUAL
    (69) cmp -> . LGREQUAL

    LGREATER        shift and go to state 119
    RGREATER        shift and go to state 120
    EQUAL           shift and go to state 121
    NOTEQUAL        shift and go to state 122
    RGREQUAL        shift and go to state 123
    LGREQUAL        shift and go to state 124

    cmp                            shift and go to state 118

state 107

    (5) func -> FLOAT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE .

    INT             reduce using rule 5 (func -> FLOAT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE .)
    FLOAT           reduce using rule 5 (func -> FLOAT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE .)
    $end            reduce using rule 5 (func -> FLOAT ID LPAREN paramlist RPAREN LBRACE stmtlist RBRACE .)


state 108

    (38) varlist -> id COMMA varlist .

    SEMICOLON       reduce using rule 38 (varlist -> id COMMA varlist .)


state 109

    (28) funccall -> ID LPAREN arglist RPAREN .

    SEMICOLON       reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)
    STAR            reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)
    DIVIDE          reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)
    PLUS            reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)
    MINUS           reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)
    COMMA           reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)
    RPAREN          reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)
    RBRACKET        reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)
    LGREATER        reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)
    RGREATER        reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)
    EQUAL           reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)
    NOTEQUAL        reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)
    RGREQUAL        reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)
    LGREQUAL        reduce using rule 28 (funccall -> ID LPAREN arglist RPAREN .)


state 110

    (30) arglist -> arg COMMA . arglist
    (30) arglist -> . arg COMMA arglist
    (31) arglist -> . arg
    (32) arg -> . arithexp
    (33) arg -> . string
    (41) arithexp -> . LPAREN arithexp RPAREN
    (42) arithexp -> . term arithexptail
    (43) arithexp -> . term
    (70) string -> . STRING
    (48) term -> . factor termtail
    (49) term -> . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 65
    STRING          shift and go to state 92
    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    arg                            shift and go to state 89
    arglist                        shift and go to state 125
    arithexp                       shift and go to state 90
    string                         shift and go to state 91
    term                           shift and go to state 66
    factor                         shift and go to state 67
    incre                          shift and go to state 71
    id                             shift and go to state 72
    funccall                       shift and go to state 73

state 111

    (63) id -> ID LBRACKET arithexp RBRACKET .

    ASSIGN          reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    INCREMENT       reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    COMMA           reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    SEMICOLON       reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    STAR            reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    DIVIDE          reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    PLUS            reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    MINUS           reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    RETURN          reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    INT             reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    FLOAT           reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    FOR             reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    IF              reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    ID              reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    RBRACE          reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    RPAREN          reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    RBRACKET        reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    LGREATER        reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    RGREATER        reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    EQUAL           reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    NOTEQUAL        reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    RGREQUAL        reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)
    LGREQUAL        reduce using rule 63 (id -> ID LBRACKET arithexp RBRACKET .)


state 112

    (41) arithexp -> LPAREN arithexp RPAREN .

    SEMICOLON       reduce using rule 41 (arithexp -> LPAREN arithexp RPAREN .)
    COMMA           reduce using rule 41 (arithexp -> LPAREN arithexp RPAREN .)
    RPAREN          reduce using rule 41 (arithexp -> LPAREN arithexp RPAREN .)
    RBRACKET        reduce using rule 41 (arithexp -> LPAREN arithexp RPAREN .)
    LGREATER        reduce using rule 41 (arithexp -> LPAREN arithexp RPAREN .)
    RGREATER        reduce using rule 41 (arithexp -> LPAREN arithexp RPAREN .)
    EQUAL           reduce using rule 41 (arithexp -> LPAREN arithexp RPAREN .)
    NOTEQUAL        reduce using rule 41 (arithexp -> LPAREN arithexp RPAREN .)
    RGREQUAL        reduce using rule 41 (arithexp -> LPAREN arithexp RPAREN .)
    LGREQUAL        reduce using rule 41 (arithexp -> LPAREN arithexp RPAREN .)


state 113

    (44) arithexptail -> PLUS term . arithexptail
    (45) arithexptail -> PLUS term .
    (44) arithexptail -> . PLUS term arithexptail
    (45) arithexptail -> . PLUS term
    (46) arithexptail -> . MINUS term arithexptail
    (47) arithexptail -> . MINUS term

    SEMICOLON       reduce using rule 45 (arithexptail -> PLUS term .)
    COMMA           reduce using rule 45 (arithexptail -> PLUS term .)
    RPAREN          reduce using rule 45 (arithexptail -> PLUS term .)
    RBRACKET        reduce using rule 45 (arithexptail -> PLUS term .)
    LGREATER        reduce using rule 45 (arithexptail -> PLUS term .)
    RGREATER        reduce using rule 45 (arithexptail -> PLUS term .)
    EQUAL           reduce using rule 45 (arithexptail -> PLUS term .)
    NOTEQUAL        reduce using rule 45 (arithexptail -> PLUS term .)
    RGREQUAL        reduce using rule 45 (arithexptail -> PLUS term .)
    LGREQUAL        reduce using rule 45 (arithexptail -> PLUS term .)
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97

    arithexptail                   shift and go to state 126

state 114

    (46) arithexptail -> MINUS term . arithexptail
    (47) arithexptail -> MINUS term .
    (44) arithexptail -> . PLUS term arithexptail
    (45) arithexptail -> . PLUS term
    (46) arithexptail -> . MINUS term arithexptail
    (47) arithexptail -> . MINUS term

    SEMICOLON       reduce using rule 47 (arithexptail -> MINUS term .)
    COMMA           reduce using rule 47 (arithexptail -> MINUS term .)
    RPAREN          reduce using rule 47 (arithexptail -> MINUS term .)
    RBRACKET        reduce using rule 47 (arithexptail -> MINUS term .)
    LGREATER        reduce using rule 47 (arithexptail -> MINUS term .)
    RGREATER        reduce using rule 47 (arithexptail -> MINUS term .)
    EQUAL           reduce using rule 47 (arithexptail -> MINUS term .)
    NOTEQUAL        reduce using rule 47 (arithexptail -> MINUS term .)
    RGREQUAL        reduce using rule 47 (arithexptail -> MINUS term .)
    LGREQUAL        reduce using rule 47 (arithexptail -> MINUS term .)
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97

    arithexptail                   shift and go to state 127

state 115

    (50) termtail -> STAR factor . termtail
    (51) termtail -> STAR factor .
    (50) termtail -> . STAR factor termtail
    (51) termtail -> . STAR factor
    (52) termtail -> . DIVIDE factor termtail
    (53) termtail -> . DIVIDE factor

    PLUS            reduce using rule 51 (termtail -> STAR factor .)
    MINUS           reduce using rule 51 (termtail -> STAR factor .)
    SEMICOLON       reduce using rule 51 (termtail -> STAR factor .)
    COMMA           reduce using rule 51 (termtail -> STAR factor .)
    RPAREN          reduce using rule 51 (termtail -> STAR factor .)
    RBRACKET        reduce using rule 51 (termtail -> STAR factor .)
    LGREATER        reduce using rule 51 (termtail -> STAR factor .)
    RGREATER        reduce using rule 51 (termtail -> STAR factor .)
    EQUAL           reduce using rule 51 (termtail -> STAR factor .)
    NOTEQUAL        reduce using rule 51 (termtail -> STAR factor .)
    RGREQUAL        reduce using rule 51 (termtail -> STAR factor .)
    LGREQUAL        reduce using rule 51 (termtail -> STAR factor .)
    STAR            shift and go to state 99
    DIVIDE          shift and go to state 100

    termtail                       shift and go to state 128

state 116

    (52) termtail -> DIVIDE factor . termtail
    (53) termtail -> DIVIDE factor .
    (50) termtail -> . STAR factor termtail
    (51) termtail -> . STAR factor
    (52) termtail -> . DIVIDE factor termtail
    (53) termtail -> . DIVIDE factor

    PLUS            reduce using rule 53 (termtail -> DIVIDE factor .)
    MINUS           reduce using rule 53 (termtail -> DIVIDE factor .)
    SEMICOLON       reduce using rule 53 (termtail -> DIVIDE factor .)
    COMMA           reduce using rule 53 (termtail -> DIVIDE factor .)
    RPAREN          reduce using rule 53 (termtail -> DIVIDE factor .)
    RBRACKET        reduce using rule 53 (termtail -> DIVIDE factor .)
    LGREATER        reduce using rule 53 (termtail -> DIVIDE factor .)
    RGREATER        reduce using rule 53 (termtail -> DIVIDE factor .)
    EQUAL           reduce using rule 53 (termtail -> DIVIDE factor .)
    NOTEQUAL        reduce using rule 53 (termtail -> DIVIDE factor .)
    RGREQUAL        reduce using rule 53 (termtail -> DIVIDE factor .)
    LGREQUAL        reduce using rule 53 (termtail -> DIVIDE factor .)
    STAR            shift and go to state 99
    DIVIDE          shift and go to state 100

    termtail                       shift and go to state 129

state 117

    (26) forloop -> FOR LPAREN id ASSIGN . arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE
    (41) arithexp -> . LPAREN arithexp RPAREN
    (42) arithexp -> . term arithexptail
    (43) arithexp -> . term
    (48) term -> . factor termtail
    (49) term -> . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 65
    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    id                             shift and go to state 72
    arithexp                       shift and go to state 130
    incre                          shift and go to state 71
    term                           shift and go to state 66
    factor                         shift and go to state 67
    funccall                       shift and go to state 73

state 118

    (27) if -> IF LPAREN arithexp cmp . arithexp RPAREN LBRACE stmtlist RBRACE
    (41) arithexp -> . LPAREN arithexp RPAREN
    (42) arithexp -> . term arithexptail
    (43) arithexp -> . term
    (48) term -> . factor termtail
    (49) term -> . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 65
    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    arithexp                       shift and go to state 131
    term                           shift and go to state 66
    factor                         shift and go to state 67
    incre                          shift and go to state 71
    id                             shift and go to state 72
    funccall                       shift and go to state 73

state 119

    (64) cmp -> LGREATER .

    LPAREN          reduce using rule 64 (cmp -> LGREATER .)
    NUMBER          reduce using rule 64 (cmp -> LGREATER .)
    PLUS            reduce using rule 64 (cmp -> LGREATER .)
    MINUS           reduce using rule 64 (cmp -> LGREATER .)
    INCREMENT       reduce using rule 64 (cmp -> LGREATER .)
    ID              reduce using rule 64 (cmp -> LGREATER .)


state 120

    (65) cmp -> RGREATER .

    LPAREN          reduce using rule 65 (cmp -> RGREATER .)
    NUMBER          reduce using rule 65 (cmp -> RGREATER .)
    PLUS            reduce using rule 65 (cmp -> RGREATER .)
    MINUS           reduce using rule 65 (cmp -> RGREATER .)
    INCREMENT       reduce using rule 65 (cmp -> RGREATER .)
    ID              reduce using rule 65 (cmp -> RGREATER .)


state 121

    (66) cmp -> EQUAL .

    LPAREN          reduce using rule 66 (cmp -> EQUAL .)
    NUMBER          reduce using rule 66 (cmp -> EQUAL .)
    PLUS            reduce using rule 66 (cmp -> EQUAL .)
    MINUS           reduce using rule 66 (cmp -> EQUAL .)
    INCREMENT       reduce using rule 66 (cmp -> EQUAL .)
    ID              reduce using rule 66 (cmp -> EQUAL .)


state 122

    (67) cmp -> NOTEQUAL .

    LPAREN          reduce using rule 67 (cmp -> NOTEQUAL .)
    NUMBER          reduce using rule 67 (cmp -> NOTEQUAL .)
    PLUS            reduce using rule 67 (cmp -> NOTEQUAL .)
    MINUS           reduce using rule 67 (cmp -> NOTEQUAL .)
    INCREMENT       reduce using rule 67 (cmp -> NOTEQUAL .)
    ID              reduce using rule 67 (cmp -> NOTEQUAL .)


state 123

    (68) cmp -> RGREQUAL .

    LPAREN          reduce using rule 68 (cmp -> RGREQUAL .)
    NUMBER          reduce using rule 68 (cmp -> RGREQUAL .)
    PLUS            reduce using rule 68 (cmp -> RGREQUAL .)
    MINUS           reduce using rule 68 (cmp -> RGREQUAL .)
    INCREMENT       reduce using rule 68 (cmp -> RGREQUAL .)
    ID              reduce using rule 68 (cmp -> RGREQUAL .)


state 124

    (69) cmp -> LGREQUAL .

    LPAREN          reduce using rule 69 (cmp -> LGREQUAL .)
    NUMBER          reduce using rule 69 (cmp -> LGREQUAL .)
    PLUS            reduce using rule 69 (cmp -> LGREQUAL .)
    MINUS           reduce using rule 69 (cmp -> LGREQUAL .)
    INCREMENT       reduce using rule 69 (cmp -> LGREQUAL .)
    ID              reduce using rule 69 (cmp -> LGREQUAL .)


state 125

    (30) arglist -> arg COMMA arglist .

    RPAREN          reduce using rule 30 (arglist -> arg COMMA arglist .)


state 126

    (44) arithexptail -> PLUS term arithexptail .

    SEMICOLON       reduce using rule 44 (arithexptail -> PLUS term arithexptail .)
    COMMA           reduce using rule 44 (arithexptail -> PLUS term arithexptail .)
    RPAREN          reduce using rule 44 (arithexptail -> PLUS term arithexptail .)
    RBRACKET        reduce using rule 44 (arithexptail -> PLUS term arithexptail .)
    LGREATER        reduce using rule 44 (arithexptail -> PLUS term arithexptail .)
    RGREATER        reduce using rule 44 (arithexptail -> PLUS term arithexptail .)
    EQUAL           reduce using rule 44 (arithexptail -> PLUS term arithexptail .)
    NOTEQUAL        reduce using rule 44 (arithexptail -> PLUS term arithexptail .)
    RGREQUAL        reduce using rule 44 (arithexptail -> PLUS term arithexptail .)
    LGREQUAL        reduce using rule 44 (arithexptail -> PLUS term arithexptail .)


state 127

    (46) arithexptail -> MINUS term arithexptail .

    SEMICOLON       reduce using rule 46 (arithexptail -> MINUS term arithexptail .)
    COMMA           reduce using rule 46 (arithexptail -> MINUS term arithexptail .)
    RPAREN          reduce using rule 46 (arithexptail -> MINUS term arithexptail .)
    RBRACKET        reduce using rule 46 (arithexptail -> MINUS term arithexptail .)
    LGREATER        reduce using rule 46 (arithexptail -> MINUS term arithexptail .)
    RGREATER        reduce using rule 46 (arithexptail -> MINUS term arithexptail .)
    EQUAL           reduce using rule 46 (arithexptail -> MINUS term arithexptail .)
    NOTEQUAL        reduce using rule 46 (arithexptail -> MINUS term arithexptail .)
    RGREQUAL        reduce using rule 46 (arithexptail -> MINUS term arithexptail .)
    LGREQUAL        reduce using rule 46 (arithexptail -> MINUS term arithexptail .)


state 128

    (50) termtail -> STAR factor termtail .

    PLUS            reduce using rule 50 (termtail -> STAR factor termtail .)
    MINUS           reduce using rule 50 (termtail -> STAR factor termtail .)
    SEMICOLON       reduce using rule 50 (termtail -> STAR factor termtail .)
    COMMA           reduce using rule 50 (termtail -> STAR factor termtail .)
    RPAREN          reduce using rule 50 (termtail -> STAR factor termtail .)
    RBRACKET        reduce using rule 50 (termtail -> STAR factor termtail .)
    LGREATER        reduce using rule 50 (termtail -> STAR factor termtail .)
    RGREATER        reduce using rule 50 (termtail -> STAR factor termtail .)
    EQUAL           reduce using rule 50 (termtail -> STAR factor termtail .)
    NOTEQUAL        reduce using rule 50 (termtail -> STAR factor termtail .)
    RGREQUAL        reduce using rule 50 (termtail -> STAR factor termtail .)
    LGREQUAL        reduce using rule 50 (termtail -> STAR factor termtail .)


state 129

    (52) termtail -> DIVIDE factor termtail .

    PLUS            reduce using rule 52 (termtail -> DIVIDE factor termtail .)
    MINUS           reduce using rule 52 (termtail -> DIVIDE factor termtail .)
    SEMICOLON       reduce using rule 52 (termtail -> DIVIDE factor termtail .)
    COMMA           reduce using rule 52 (termtail -> DIVIDE factor termtail .)
    RPAREN          reduce using rule 52 (termtail -> DIVIDE factor termtail .)
    RBRACKET        reduce using rule 52 (termtail -> DIVIDE factor termtail .)
    LGREATER        reduce using rule 52 (termtail -> DIVIDE factor termtail .)
    RGREATER        reduce using rule 52 (termtail -> DIVIDE factor termtail .)
    EQUAL           reduce using rule 52 (termtail -> DIVIDE factor termtail .)
    NOTEQUAL        reduce using rule 52 (termtail -> DIVIDE factor termtail .)
    RGREQUAL        reduce using rule 52 (termtail -> DIVIDE factor termtail .)
    LGREQUAL        reduce using rule 52 (termtail -> DIVIDE factor termtail .)


state 130

    (26) forloop -> FOR LPAREN id ASSIGN arithexp . SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE

    SEMICOLON       shift and go to state 132


state 131

    (27) if -> IF LPAREN arithexp cmp arithexp . RPAREN LBRACE stmtlist RBRACE

    RPAREN          shift and go to state 133


state 132

    (26) forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON . id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    ID              shift and go to state 55

    id                             shift and go to state 134

state 133

    (27) if -> IF LPAREN arithexp cmp arithexp RPAREN . LBRACE stmtlist RBRACE

    LBRACE          shift and go to state 135


state 134

    (26) forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id . cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE
    (64) cmp -> . LGREATER
    (65) cmp -> . RGREATER
    (66) cmp -> . EQUAL
    (67) cmp -> . NOTEQUAL
    (68) cmp -> . RGREQUAL
    (69) cmp -> . LGREQUAL

    LGREATER        shift and go to state 119
    RGREATER        shift and go to state 120
    EQUAL           shift and go to state 121
    NOTEQUAL        shift and go to state 122
    RGREQUAL        shift and go to state 123
    LGREQUAL        shift and go to state 124

    cmp                            shift and go to state 136

state 135

    (27) if -> IF LPAREN arithexp cmp arithexp RPAREN LBRACE . stmtlist RBRACE
    (15) stmtlist -> . stmt stmtlist
    (16) stmtlist -> . stmt
    (17) stmt -> . return SEMICOLON
    (18) stmt -> . declarevar SEMICOLON
    (19) stmt -> . assignvar SEMICOLON
    (20) stmt -> . forloop
    (21) stmt -> . incre
    (22) stmt -> . if
    (23) stmt -> . funccall SEMICOLON
    (24) return -> . RETURN
    (25) return -> . RETURN arithexp
    (34) declarevar -> . INT varlist
    (35) declarevar -> . FLOAT varlist
    (36) declarevar -> . INT STAR varlist
    (37) declarevar -> . FLOAT STAR varlist
    (40) assignvar -> . id ASSIGN arithexp
    (26) forloop -> . FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (27) if -> . IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    RETURN          shift and go to state 41
    INT             shift and go to state 30
    FLOAT           shift and go to state 42
    FOR             shift and go to state 44
    INCREMENT       shift and go to state 45
    IF              shift and go to state 46
    ID              shift and go to state 31

    stmtlist                       shift and go to state 137
    stmt                           shift and go to state 33
    return                         shift and go to state 34
    declarevar                     shift and go to state 35
    assignvar                      shift and go to state 36
    forloop                        shift and go to state 37
    incre                          shift and go to state 38
    if                             shift and go to state 39
    funccall                       shift and go to state 40
    id                             shift and go to state 43

state 136

    (26) forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp . arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE
    (41) arithexp -> . LPAREN arithexp RPAREN
    (42) arithexp -> . term arithexptail
    (43) arithexp -> . term
    (48) term -> . factor termtail
    (49) term -> . factor
    (54) factor -> . NUMBER
    (55) factor -> . PLUS NUMBER
    (56) factor -> . MINUS NUMBER
    (57) factor -> . incre
    (60) factor -> . id
    (61) factor -> . funccall
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN

    LPAREN          shift and go to state 65
    NUMBER          shift and go to state 68
    PLUS            shift and go to state 69
    MINUS           shift and go to state 70
    INCREMENT       shift and go to state 45
    ID              shift and go to state 74

    id                             shift and go to state 72
    arithexp                       shift and go to state 138
    incre                          shift and go to state 71
    term                           shift and go to state 66
    factor                         shift and go to state 67
    funccall                       shift and go to state 73

state 137

    (27) if -> IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist . RBRACE

    RBRACE          shift and go to state 139


state 138

    (26) forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp . SEMICOLON incre RPAREN LBRACE stmtlist RBRACE

    SEMICOLON       shift and go to state 140


state 139

    (27) if -> IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE .

    RETURN          reduce using rule 27 (if -> IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE .)
    INT             reduce using rule 27 (if -> IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE .)
    FLOAT           reduce using rule 27 (if -> IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE .)
    FOR             reduce using rule 27 (if -> IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE .)
    INCREMENT       reduce using rule 27 (if -> IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE .)
    IF              reduce using rule 27 (if -> IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE .)
    ID              reduce using rule 27 (if -> IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE .)
    RBRACE          reduce using rule 27 (if -> IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE .)


state 140

    (26) forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON . incre RPAREN LBRACE stmtlist RBRACE
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    INCREMENT       shift and go to state 45
    ID              shift and go to state 55

    id                             shift and go to state 141
    incre                          shift and go to state 142

state 141

    (59) incre -> id . INCREMENT

    INCREMENT       shift and go to state 78


state 142

    (26) forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre . RPAREN LBRACE stmtlist RBRACE

    RPAREN          shift and go to state 143


state 143

    (26) forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN . LBRACE stmtlist RBRACE

    LBRACE          shift and go to state 144


state 144

    (26) forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE . stmtlist RBRACE
    (15) stmtlist -> . stmt stmtlist
    (16) stmtlist -> . stmt
    (17) stmt -> . return SEMICOLON
    (18) stmt -> . declarevar SEMICOLON
    (19) stmt -> . assignvar SEMICOLON
    (20) stmt -> . forloop
    (21) stmt -> . incre
    (22) stmt -> . if
    (23) stmt -> . funccall SEMICOLON
    (24) return -> . RETURN
    (25) return -> . RETURN arithexp
    (34) declarevar -> . INT varlist
    (35) declarevar -> . FLOAT varlist
    (36) declarevar -> . INT STAR varlist
    (37) declarevar -> . FLOAT STAR varlist
    (40) assignvar -> . id ASSIGN arithexp
    (26) forloop -> . FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE
    (58) incre -> . INCREMENT id
    (59) incre -> . id INCREMENT
    (27) if -> . IF LPAREN arithexp cmp arithexp RPAREN LBRACE stmtlist RBRACE
    (28) funccall -> . ID LPAREN arglist RPAREN
    (29) funccall -> . ID LPAREN RPAREN
    (62) id -> . ID
    (63) id -> . ID LBRACKET arithexp RBRACKET

    RETURN          shift and go to state 41
    INT             shift and go to state 30
    FLOAT           shift and go to state 42
    FOR             shift and go to state 44
    INCREMENT       shift and go to state 45
    IF              shift and go to state 46
    ID              shift and go to state 31

    id                             shift and go to state 43
    incre                          shift and go to state 38
    stmtlist                       shift and go to state 145
    stmt                           shift and go to state 33
    return                         shift and go to state 34
    declarevar                     shift and go to state 35
    assignvar                      shift and go to state 36
    forloop                        shift and go to state 37
    if                             shift and go to state 39
    funccall                       shift and go to state 40

state 145

    (26) forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist . RBRACE

    RBRACE          shift and go to state 146


state 146

    (26) forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE .

    RETURN          reduce using rule 26 (forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE .)
    INT             reduce using rule 26 (forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE .)
    FLOAT           reduce using rule 26 (forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE .)
    FOR             reduce using rule 26 (forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE .)
    INCREMENT       reduce using rule 26 (forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE .)
    IF              reduce using rule 26 (forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE .)
    ID              reduce using rule 26 (forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE .)
    RBRACE          reduce using rule 26 (forloop -> FOR LPAREN id ASSIGN arithexp SEMICOLON id cmp arithexp SEMICOLON incre RPAREN LBRACE stmtlist RBRACE .)

